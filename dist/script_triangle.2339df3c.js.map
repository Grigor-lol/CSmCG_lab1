{"version":3,"sources":["java-script/vertex_triangle.glsl","java-script/fragment_triangle.glsl","java-script/script_triangle.js"],"names":["module","exports","gl","_vertex_triangle","_interopRequireDefault","require","_fragment_triangle","obj","__esModule","default","start","canvas","document","getElementById","initWebGL","viewport","width","height","clearColor","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","vsSource","vertex","fsSource","fragment","vertexShader","createShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","initShaderProgram","triangleVerticesBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","useProgram","vertexPositionAttribute","getAttribLocation","vertexColorAttribute","enableVertexAttribArray","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawArrays","TRIANGLE_STRIP","alert","names","ii","length","getContext","e","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader"],"mappings":";AAAAA,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;AC2Gf,aA3GA,IAEIC,EAFJC,EAAAC,EAAAC,QAAA,2BACAC,EAAAF,EAAAC,QAAA,6BAA+C,SAAAD,EAAAG,GAAAA,OAAAA,GAAAA,EAAAC,WAAAD,EAAAE,CAAAA,QAAAF,GAK/C,SAASG,IACL,IAAIC,EAASC,SAASC,eAAe,YAErC,GADAX,EAAKY,EAAUH,GACf,CAKAT,EAAGa,SAAS,EAAG,EAAGb,EAAGS,OAAOK,MAAOd,EAAGS,OAAOM,QAE7Cf,EAAGgB,WAAW,EAAK,EAAK,EAAK,GAE7BhB,EAAGiB,OAAOjB,EAAGkB,YAEblB,EAAGmB,UAAUnB,EAAGoB,QAEhBpB,EAAGqB,MAAMrB,EAAGsB,iBAAiBtB,EAAGuB,kBAChC,IAAMC,EAAWC,EAAM,QACjBC,EAAWC,EAAQ,QACnBC,EAAeC,EAAa7B,EAAIA,EAAG8B,cAAeN,GAClDO,EAAiBF,EAAa7B,EAAIA,EAAGgC,gBAAiBN,GACtDO,EAAgBC,EAAkBlC,EAAI4B,EAAcG,GAOtDI,EAAyBnC,EAAGoC,eAChCpC,EAAGqC,WAAWrC,EAAGsC,aAAcH,GAC/BnC,EAAGuC,WAAWvC,EAAGsC,aAAc,IAAIE,aAPpB,CACX,EAAK,EAAK,EAAG,EAAG,GACf,GAAM,EAAK,EAAG,EAAG,EAClB,GAAM,EAAK,EAAG,EAAG,IAIsCxC,EAAGyC,aAW9DzC,EAAG0C,WAAWT,GAEd,IAAIU,EAA0B3C,EAAG4C,kBAAkBX,EAAe,cAC9DY,EAAuB7C,EAAG4C,kBAAkBX,EAAe,WAC/DjC,EAAG8C,wBAAwBH,GAC3B3C,EAAG8C,wBAAwBD,GAE3B7C,EAAGqB,MAAMrB,EAAGsB,iBAAmBtB,EAAGuB,kBAKlCvB,EAAG+C,oBAAoBJ,EAAyB,EAAG3C,EAAGgD,OAAO,EAAO,EAAER,aAAaS,kBAAmB,GACtGjD,EAAG+C,oBAAoBF,EAAsB,EAAG7C,EAAGgD,OAAO,EAAO,EAAER,aAAaS,kBAAmB,EAAET,aAAaS,mBAElHjD,EAAGkD,WAAWlD,EAAGmD,eAAgB,EAAG,QApDhCC,MAAM,2EAuDd,SAASxC,EAAUH,GACfT,EAAK,KACL,IAAIqD,EAAQ,CAAC,SAAU,QAAS,qBAAsB,YAAa,aACnErD,EAAK,KACL,IAAK,IAAIsD,EAAK,EAAGA,EAAKD,EAAME,SAAUD,EAAI,CACtC,IACItD,EAAKS,EAAO+C,WAAWH,EAAMC,IAC/B,MAAMG,IACR,GAAIzD,EACA,MAGR,OAAOA,EAGX,SAASkC,EAAkBlC,EAAI4B,EAAcG,GAGzC,IAAME,EAAgBjC,EAAG0D,gBAKzB,OAJA1D,EAAG2D,aAAa1B,EAAeL,GAC/B5B,EAAG2D,aAAa1B,EAAeF,GAC/B/B,EAAG4D,YAAY3B,GAEVjC,EAAG6D,oBAAoB5B,EAAejC,EAAG8D,aAIvC7B,GAHHmB,MAAM,4CAA8CpD,EAAG+D,kBAAkB9B,IAClE,MAMf,SAASJ,EAAa7B,EAAIgE,EAAMC,GAC5B,IAAMC,EAASlE,EAAG6B,aAAamC,GAI/B,GAHAhE,EAAGmE,aAAaD,EAAQD,GACxBjE,EAAGoE,cAAcF,GACDlE,EAAGqE,mBAAmBH,EAAQlE,EAAGsE,gBAE7C,OAAOJ,EAGXd,MAAM,4CAA8CpD,EAAGuE,iBAAiBL,IACxElE,EAAGwE,aAAaN,GAtGpB1D","file":"script_triangle.2339df3c.js","sourceRoot":"..","sourcesContent":["module.exports=\"#define GLSLIFY 1\\n// an attribute will receive data from a buffer\\nattribute vec2 a_position;\\nattribute vec3 a_color;\\n\\nvarying vec3 fragColor;\\n// all shaders have a main function\\nvoid main() {\\n\\n    // gl_Position is a special variable a vertex shader\\n    // is responsible for setting\\n    fragColor = a_color;\\n    gl_Position = vec4(a_position, 0.0, 1.0);\\n}\";","module.exports=\"// fragment shaders don't have a default precision so we need\\n// to pick one. mediump is a good default\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nvarying vec3 fragColor;\\nvoid main() {\\n    // gl_FragColor is a special variable a fragment shader\\n    // is responsible for setting\\n    gl_FragColor = vec4(fragColor, 1.0); // return redish-purple\\n}\";","import vertex from './vertex_triangle.glsl'\r\nimport fragment from './fragment_triangle.glsl'\r\nvar gl;\r\n\r\nstart();\r\n\r\nfunction start() {\r\n    var canvas = document.getElementById(\"glcanvas\");\r\n    gl = initWebGL(canvas);\r\n    if (!gl) {\r\n        alert('Unable to initialize WebGL. Your browser or machine may not support it.');\r\n        return;\r\n    }// продолжать только если WebGL доступен и работает\r\n// Устанавливаем размер вьюпорта\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n// установить в качестве цвета очистки буфера цвета черный, полная непрозрачность\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n// включает использование буфера глубины\r\n    gl.enable(gl.DEPTH_TEST);\r\n// определяет работу буфера глубины: более ближние объекты перекрывают дальние\r\n    gl.depthFunc(gl.LEQUAL);\r\n// очистить буфер цвета и буфер глубины\r\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\r\n    const vsSource = vertex;\r\n    const fsSource = fragment;\r\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource );\r\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n    const shaderProgram = initShaderProgram(gl, vertexShader, fragmentShader);\r\n\r\n    var vertices = [\r\n        0.0, 1.0, 1, 0, 0,\r\n        -1.0, -1.0, 0, 1, 0,\r\n        1.0, -1.0, 0, 0, 1,\r\n    ];\r\n    var triangleVerticesBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticesBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n\r\n    // var colors = [\r\n    //     1, 0, 0,\r\n    //     0, 1, 0,\r\n    //     0, 0, 1,\r\n    // ];\r\n    // var colorsBuffer = gl.createBuffer();\r\n    // gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\r\n    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    gl.useProgram(shaderProgram);\r\n\r\n    var vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"a_position\");\r\n    var vertexColorAttribute = gl.getAttribLocation(shaderProgram, \"a_color\");\r\n    gl.enableVertexAttribArray(vertexPositionAttribute);\r\n    gl.enableVertexAttribArray(vertexColorAttribute);\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    //gl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticesBuffer);\r\n    //gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\r\n\r\n    gl.vertexAttribPointer(vertexPositionAttribute, 2, gl.FLOAT, false, 5*Float32Array.BYTES_PER_ELEMENT, 0);\r\n    gl.vertexAttribPointer(vertexColorAttribute, 3, gl.FLOAT, false, 5*Float32Array.BYTES_PER_ELEMENT, 2*Float32Array.BYTES_PER_ELEMENT);\r\n\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 3);\r\n}\r\n\r\nfunction initWebGL(canvas) {\r\n    gl = null;\r\n    var names = [\"webgl2\", \"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n    gl = null;\r\n    for (var ii = 0; ii < names.length; ++ii) {\r\n        try {\r\n            gl = canvas.getContext(names[ii]);\r\n        } catch(e) {}\r\n        if (gl) {\r\n            break;\r\n        }\r\n    }\r\n    return gl;\r\n}\r\n\r\nfunction initShaderProgram(gl, vertexShader, fragmentShader) {\r\n\r\n\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n// If creating the shader program failed, alert\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n        return null;\r\n    }\r\n    return shaderProgram;\r\n\r\n}\r\n\r\nfunction createShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (success) {\r\n        return shader;\r\n    }\r\n\r\n    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n}\r\n\r\n"]}