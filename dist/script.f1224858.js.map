{"version":3,"sources":["java-script/vertex.glsl","java-script/fragment.glsl","java-script/script.js"],"names":["module","exports","gl","_vertex","_interopRequireDefault","require","_fragment","obj","__esModule","default","start","canvas","document","getElementById","initWebGL","viewport","width","height","clearColor","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","vertexPositionAttribute","vsSource","vertex","fsSource","fragment","vertexShader","createShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","initShaderProgram","useProgram","getAttribLocation","enableVertexAttribArray","initBuffers","drawScene","alert","names","ii","length","getContext","e","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","loadShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","squareVerticesBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","vertexAttribPointer","FLOAT","drawArrays","TRIANGLE_STRIP","console","log"],"mappings":";AAAAA,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;ACmHf,aAnHA,IAEIC,EAFJC,EAAAC,EAAAC,QAAA,kBACAC,EAAAF,EAAAC,QAAA,oBAAsC,SAAAD,EAAAG,GAAAA,OAAAA,GAAAA,EAAAC,WAAAD,EAAAE,CAAAA,QAAAF,GAKtC,SAASG,IACL,IAAIC,EAASC,SAASC,eAAe,YAErC,GADAX,EAAKY,EAAUH,GACf,CAKAT,EAAGa,SAAS,EAAG,EAAGb,EAAGS,OAAOK,MAAOd,EAAGS,OAAOM,QAE7Cf,EAAGgB,WAAW,EAAK,EAAK,EAAK,GAE7BhB,EAAGiB,OAAOjB,EAAGkB,YAEblB,EAAGmB,UAAUnB,EAAGoB,QAEhBpB,EAAGqB,MAAMrB,EAAGsB,iBAAiBtB,EAAGuB,kBAChC,IAOIC,EAPEC,EAAWC,EAAM,QACjBC,EAAWC,EAAQ,QACnBC,EAAeC,EAAa9B,EAAIA,EAAG+B,cAAeN,GAClDO,EAAiBF,EAAa9B,EAAIA,EAAGiC,gBAAiBN,GACtDO,EAAgBC,EAAkBnC,EAAI6B,EAAcG,GAC1DhC,EAAGoC,WAAWF,GAGdV,EAA0BxB,EAAGqC,kBAAkBH,EAAe,cAC9DlC,EAAGsC,wBAAwBd,GAC3Be,IACAC,SAxBIC,MAAM,2EA2Bd,SAAS7B,EAAUH,GACfT,EAAK,KACL,IAAI0C,EAAQ,CAAC,SAAU,QAAS,qBAAsB,YAAa,aACnE1C,EAAK,KACL,IAAK,IAAI2C,EAAK,EAAGA,EAAKD,EAAME,SAAUD,EAAI,CACtC,IACI3C,EAAKS,EAAOoC,WAAWH,EAAMC,IAC/B,MAAMG,IACR,GAAI9C,EACA,MAGR,OAAOA,EAGX,SAASmC,EAAkBnC,EAAI6B,EAAcG,GAGzC,IAAME,EAAgBlC,EAAG+C,gBAKzB,OAJA/C,EAAGgD,aAAad,EAAeL,GAC/B7B,EAAGgD,aAAad,EAAeF,GAC/BhC,EAAGiD,YAAYf,GAEVlC,EAAGkD,oBAAoBhB,EAAelC,EAAGmD,aAIvCjB,GAHHO,MAAM,4CAA8CzC,EAAGoD,kBAAkBlB,IAClE,MAMf,SAASmB,EAAWrD,EAAIsD,EAAMC,GAC1B,IAAMC,EAASxD,EAAG8B,aAAawB,GAM/B,OAJAtD,EAAGyD,aAAaD,EAAQD,GAExBvD,EAAG0D,cAAcF,GAEZxD,EAAG2D,mBAAmBH,EAAQxD,EAAG4D,gBAK/BJ,GAJHf,MAAM,4CAA8CzC,EAAG6D,iBAAiBL,IACxExD,EAAG8D,aAAaN,GACT,MAKf,SAASjB,IACL,IAAIwB,EACJA,EAAuB/D,EAAGgE,eAC1BhE,EAAGiE,WAAWjE,EAAGkE,aAAcH,GAO/B/D,EAAGmE,WAAWnE,EAAGkE,aAAc,IAAIE,aANpB,CACX,EAAK,EAAK,GACT,EAAK,EAAK,EACX,GAAM,EAAK,GACV,GAAM,EAAK,IAE2CpE,EAAGqE,aAGlE,SAAS7B,IACLxC,EAAGqB,MAAMrB,EAAGsB,iBAAmBtB,EAAGuB,kBAElCvB,EAAGiE,WAAWjE,EAAGkE,aAAcH,sBAC/B/D,EAAGsE,oBAAoB9C,wBAAyB,EAAGxB,EAAGuE,OAAO,EAAO,EAAG,GACvEvE,EAAGwE,WAAWxE,EAAGyE,eAAgB,EAAG,GAGxC,SAAS3C,EAAa9B,EAAIsD,EAAMC,GAC5B,IAAMC,EAASxD,EAAG8B,aAAawB,GAI/B,GAHAtD,EAAGyD,aAAaD,EAAQD,GACxBvD,EAAG0D,cAAcF,GACDxD,EAAG2D,mBAAmBH,EAAQxD,EAAG4D,gBAE7C,OAAOJ,EAGXkB,QAAQC,IAAI3E,EAAG6D,iBAAiBL,IAChCxD,EAAG8D,aAAaN,GA9GpBhD","file":"script.f1224858.js","sourceRoot":"..","sourcesContent":["module.exports=\"#define GLSLIFY 1\\n// an attribute will receive data from a buffer\\nattribute vec4 a_position;\\n\\n// all shaders have a main function\\nvoid main() {\\n\\n    // gl_Position is a special variable a vertex shader\\n    // is responsible for setting\\n    gl_Position = a_position;\\n}\";","module.exports=\"// fragment shaders don't have a default precision so we need\\n// to pick one. mediump is a good default\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nvoid main() {\\n    // gl_FragColor is a special variable a fragment shader\\n    // is responsible for setting\\n    gl_FragColor = vec4(1, 0, 0, 1); // return redish-purple\\n}\";","import vertex from './vertex.glsl'\r\nimport fragment from './fragment.glsl'\r\nvar gl;\r\n\r\nstart();\r\n\r\nfunction start() {\r\n    var canvas = document.getElementById(\"glcanvas\");\r\n    gl = initWebGL(canvas);\r\n    if (!gl) {\r\n        alert('Unable to initialize WebGL. Your browser or machine may not support it.');\r\n        return;\r\n    }// продолжать только если WebGL доступен и работает\r\n// Устанавливаем размер вьюпорта\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n// установить в качестве цвета очистки буфера цвета черный, полная непрозрачность\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n// включает использование буфера глубины\r\n    gl.enable(gl.DEPTH_TEST);\r\n// определяет работу буфера глубины: более ближние объекты перекрывают дальние\r\n    gl.depthFunc(gl.LEQUAL);\r\n// очистить буфер цвета и буфер глубины\r\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\r\n    const vsSource = vertex;\r\n    const fsSource = fragment;\r\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource );\r\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n    const shaderProgram = initShaderProgram(gl, vertexShader, fragmentShader);\r\n    gl.useProgram(shaderProgram);\r\n\r\n    let vertexPositionAttribute;\r\n    vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"a_position\");\r\n    gl.enableVertexAttribArray(vertexPositionAttribute);\r\n    initBuffers()\r\n    drawScene()\r\n}\r\n\r\nfunction initWebGL(canvas) {\r\n    gl = null;\r\n    var names = [\"webgl2\", \"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n    gl = null;\r\n    for (var ii = 0; ii < names.length; ++ii) {\r\n        try {\r\n            gl = canvas.getContext(names[ii]);\r\n        } catch(e) {}\r\n        if (gl) {\r\n            break;\r\n        }\r\n    }\r\n    return gl;\r\n}\r\n\r\nfunction initShaderProgram(gl, vertexShader, fragmentShader) {\r\n\r\n\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n// If creating the shader program failed, alert\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n        return null;\r\n    }\r\n    return shaderProgram;\r\n\r\n}\r\n\r\nfunction loadShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n// Send the source to the shader object\r\n    gl.shaderSource(shader, source);\r\n// Compile the shader program\r\n    gl.compileShader(shader);\r\n// See if it compiled successfully\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n    return shader;\r\n}\r\n\r\nfunction initBuffers() {\r\n    let squareVerticesBuffer;\r\n    squareVerticesBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);\r\n    var vertices = [\r\n        1.0, 1.0, 0.0,\r\n        -1.0, 1.0, 0.0,\r\n        1.0, -1.0, 0.0,\r\n        -1.0, -1.0, 0.0\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n}\r\n\r\nfunction drawScene() {\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);\r\n    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n}\r\n\r\nfunction createShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (success) {\r\n        return shader;\r\n    }\r\n\r\n    console.log(gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n}"]}